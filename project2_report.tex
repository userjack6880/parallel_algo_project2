\documentclass{article}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{ {./} }
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, plotmarks}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{decision} = [diamond, aspect=2, minimum width=3cm, minimum height=1cm, text centered, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth]
\usepackage{float}
\usepackage{listings}

\setlength{\belowcaptionskip}{10pt}

\title{Project 2: Parallel Fluid Dynamics Simulation}
\author{John Bradley}
\date{\today}

\begin{document}
  \maketitle

  \section{Introduction}

  This report aims to document the implementation and analysis of a program
  that utilizes OpenMP to implement a computational fluid dynamics model
  suitable for modeling behavior of turbulent flows. This report will cover the
  methods and techniques utilized for implementing the fluid dynamics model
  using OpenMP, analyze and estimate the expected performance of the 
  implementation, present the results from experimentation, compare and contrast 
  the expected performance to the observed results, and conclude with insights 
  and possible changes that could be made to the implementation
  
  \section{Methods and Techniques}

  Many of the functions in the code provided deal with sequential
  sections of memory, and allowing a single thread to access these sequential
  memory areas would be beneficial. Additionally, there are many nested loops.
  The Ptolemy system does not have \verb|OMP_NESTED| set by default, thus the
  use of nested \verb|#pragma omp for| declarations should be avoided. To do
  so, careful selection of partitioning of parallel and serial sections need to
  be made to exploit sequential memory access.

  For example, in the \verb|setInitialCOnditions()| function, the inner-most
  nested loop contains:

  \begin{lstlisting}[language=C, linewidth=1\textwidth, breaklines=true]
for(int k=0; k<nk; ++k) {
  int indx = offset + k;
  float dz = (1./nk)*L;
  float z = 0.5*dz+k*dz - 0.5*L;

  // 3-D taylor green vortex
  u[indx] = 1.*coef*sin(x/l)*cos(y/l)*cos(z/l);
  v[indx] = -1.*coef*cos(x/l)*sin(y/l)*cos(z/l);
  p[indx] = (1./16.)*coef*coef*(cos(2.*x/l)+cos(2.*y/l))*(cos(2.*z/l)+2.);
  w[indx] = 0;
}
  \end{lstlisting}

  For each iteration of the loop, \verb|indx| is the sum of \verb|offset|,
  defined in the outer loop, and the value of \verb|k|, which is incremented
  each iteration of the loop. If the loop was parallelized, each thread may
  access non-sequential sections of the \verb|u|, \verb|v|, \verb|p|, and
  \verb|w| arrays. If we, instead, parallelize the loop that contains the
  "\verb|k|" loop, then we can exploit this memory access pattern

  Similarily, this pattern of access is present across many of the functions in
  the program, and can be exploited in the same way.

  \section{Analysis}

  

  \section{Results}

 

  \section{Synthesis}

 

  \section{Conclusion}



\end{document}

